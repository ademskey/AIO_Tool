# -*- coding: utf-8 -*-
"""gerber.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1INK1F30vVfvY9uKKIWEShLXBsT2lpBwg
"""

# !pip install ultralytics
# !pip install roboflow
# !pip install matplotlib
# !pip install NumPy
# !pip install shapely
# !pip install gerber_writer
# !pip install pcb-tools
# !pip install opencv-python

from roboflow import Roboflow
from ultralytics import YOLO
from ultralytics.data.converter import convert_coco
import matplotlib.pyplot as plt
import numpy as np
from shapely import box
import os
import cv2
#https://github.com/ultralytics/JSON2YOLO
#https://docs.ultralytics.com/datasets/segment/#supported-datasets

# Load the model from a filepath
model = YOLO("300_AIOModel.pt")

# Get a model prediction from an image
results = model("images/062.jpg")

# model.names returns a dictionary {0: "L1", 1: "L2", 2: "Both"}
class_names = model.names

# Extract labels and masks for image (results[0] is the first image)
labels = results[0].boxes.cls.cpu().numpy() # Numpy array of class IDs for each detection
masks = results[0].masks.data.cpu().numpy()  # shape: [N, H, W]

'''
Notes:
results.masks contains predicted masks (in shape) and related data
  data = The actual predicted masks as a tensor of shape [N, H, W]
  orig_shape = Original image shape (height, width)
  segments = polygons/contours for masks (if computed)
  xy = list of per-mask polygon points (when results.masks.xy is used)

results.masks.shape returns the results of results.mask.data.shape and contains and is a 3D NumPy array of shape (N, H, W).
N = number of objects detected
H = Height of image
W = width of image

'''

# Create the blank mask for each class to use with just height and width
h, w = masks.shape[1:]

# for each class, this creates an empty binary (mask) of shape (h, w), each pixl init to 0
# dtype=np.uint8 means each pixel uses 8 bits and is common format for binary masks
layer_masks = {name: np.zeros((h, w), dtype=np.uint8) for name in class_names.values()}

# Combine masks per class
for i in range(len(masks)):   # will only loop once lol, leaving for scalability
    # Just sets the id, name, and mask
    class_id = int(labels[i])
    class_name = class_names[class_id]
    mask = masks[i]

    '''
    This bit is important. First, it takes each mask with a confidence score over
    50% and converts it from the yolo-outputted tensor to a binairy mask. This is what
    each piece does

    .astype(np.uint8)	Converts boolean to integers (0 or 1)	NumPy operations need integer mask for further processing
    * 255	Scales mask values to image format (0 or 255)	255 = white pixel in mask image (standard)
    np.maximum()	Merges this new mask into the existing layer mask. Ensures all detections for the class are included
    '''
    binary_mask = (mask > 0.5).astype(np.uint8) * 255
    layer_masks[class_name] = np.maximum(layer_masks[class_name], binary_mask)

'''
This function takes a provided mask, filename, and dots per inch (DPI) and
converts that to a Gerber polygon to write to a file

DPI = dots per inch, used to convert pixels into real-world dimensions in inches
mask = 2d numpy array for a binairy image
filename = name for file to write to
'''
def mask_to_gerber_polygon(mask, filename, dpi=96):
    scale = 1 / dpi  # Creates the scaling factor based on dpi (96 is default)

    # Extracts the outer edges (contour) of white shapes in the mask
    # TODO: see if grabbing just contours reduces accuracy
    # cv2.RETR_EXTERNAL retrieves outer contours, ignoring holes inside shapes
    # cv2.CHAIN_APPROX_SIMPLE: Simplifies the contour by removing redundant points
    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    with open(filename, "w") as f:
        # Writes file specification line, leading zero suppresion, and coordinate format
        f.write("%FSLAX24Y24*%\n")
        # Sets units to inches
        f.write("%MOIN*%\n")
        # Gerber command: G36* starts a polygon fill area.
        # Everything after this (until G37*) will define the boundary of a filled region
        f.write("G36*\n")  # Begin polygon

        # Loop of each contour (outline) found in the mask
        for contour in contours:

            # Each contour is a list of 2D points representing the outline of a white blob
            # point[0] accesses the actual (x, y) values from OpenCV's format
            for j, point in enumerate(contour):
                x, y = point[0]

                # Convert to inches and then 4-digit Gerber format
                x_in = int(x * scale * 10000)
                y_in = int(y * scale * 10000)

                # If j is zero, starting new contour
                if j == 0:

                # D02* = "move to this point" without drawing
                # D01* = "draw a line from the previous point to this point"

                    f.write(f"X{x_in}Y{y_in}D02*\n")  # Move to
                else:
                    f.write(f"X{x_in}Y{y_in}D01*\n")  # Draw to

        # G37* tells the renderer that the filled polygon is complete
        f.write("G37*\n")

        # M02* = End-of-File marker for Gerber
        f.write("M02*\n")

output_dir = "gerber_output"
os.makedirs(output_dir, exist_ok=True)

# For each class name and mask, draws the gerber and puts it in the output directory
for class_name, mask in layer_masks.items():
    if np.any(mask):  # only if the mask is non-empty
        filename = os.path.join(output_dir, f"{class_name}.gbr")
        mask_to_gerber_polygon(mask, filename)
        print(f"Wrote: {filename}")

# Visualize the prediction
# Get the annotated image (NumPy array with boxes drawn)
annotated_frame = results[0].plot()

# Show it with matplotlib
plt.imshow(annotated_frame)
plt.axis("off")
plt.show()